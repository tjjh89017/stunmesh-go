// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"github.com/tjjh89017/stunmesh-go/internal/config"
	"github.com/tjjh89017/stunmesh-go/internal/crypto"
	"github.com/tjjh89017/stunmesh-go/internal/ctrl"
	"github.com/tjjh89017/stunmesh-go/internal/daemon"
	"github.com/tjjh89017/stunmesh-go/internal/entity"
	"github.com/tjjh89017/stunmesh-go/internal/logger"
	"github.com/tjjh89017/stunmesh-go/internal/queue"
	"github.com/tjjh89017/stunmesh-go/internal/repo"
	"github.com/tjjh89017/stunmesh-go/internal/stun"
	"github.com/tjjh89017/stunmesh-go/plugin"
	"golang.zx2c4.com/wireguard/wgctrl"
)

// Injectors from wire.go:

func setup(configPath string) (*daemon.Daemon, error) {
	configConfig, err := config.LoadWithPath(configPath)
	if err != nil {
		return nil, err
	}
	queue := provideRefreshQueue()
	client, err := wgctrl.New()
	if err != nil {
		return nil, err
	}
	devices := repo.NewDevices()
	peers := repo.NewPeers(client)
	zerologLogger := logger.NewLogger(configConfig)
	deviceConfig := config.NewDeviceConfig(configConfig)
	filterPeerService := entity.NewFilterPeerService(peers, deviceConfig)
	bootstrapController := ctrl.NewBootstrapController(client, configConfig, devices, peers, zerologLogger, filterPeerService)
	manager, err := providePluginManager(configConfig)
	if err != nil {
		return nil, err
	}
	resolver := stun.NewResolver(configConfig, zerologLogger)
	endpoint := crypto.NewEndpoint()
	publishController := ctrl.NewPublishController(devices, peers, manager, resolver, endpoint, zerologLogger)
	establishController := ctrl.NewEstablishController(client, devices, peers, manager, endpoint, zerologLogger)
	refreshController := ctrl.NewRefreshController(peers, queue, zerologLogger)
	daemonDaemon := daemon.New(configConfig, queue, bootstrapController, publishController, establishController, refreshController, zerologLogger)
	return daemonDaemon, nil
}

// wire.go:

func providePluginManager(config2 *config.Config) (*plugin.Manager, error) {
	manager := plugin.NewManager()
	ctx := context.Background()

	pluginsMap := make(map[string]plugin.PluginDefinition)
	for name, def := range config2.Plugins {
		pluginsMap[name] = plugin.PluginDefinition{
			Type:   def.Type,
			Config: plugin.PluginConfig(def.Config),
		}
	}

	if err := manager.LoadPlugins(ctx, pluginsMap); err != nil {
		return nil, err
	}

	return manager, nil
}

func provideRefreshQueue() *queue.Queue[entity.PeerId] {
	return queue.New[entity.PeerId]()
}
